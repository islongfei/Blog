### 为什么要使用MQ
* 异步: 减少接口调用的感知时间，加快网站响应速度。
* 解耦：系统A只需要把消息扔到MQ就行了，其他系统按需来订阅消息就好了，提高系统可用性。
* 削峰填谷: 减少高峰时期的数据库的并发量，减少服务器负载压力，保证数据库不会挂掉，高峰过后会有消息积压消费消息的速度还会和之前一样，直到消费完积压的消息。

### 使用MQ有什么优缺点
* 优点： 异步、解耦、削峰填谷。
* 缺点： 
1. 系统可用性降低（需要考虑到MQ挂掉的场景）、
2. 系统复杂度提高（需要考虑到消息重复消费、消息丢失、消息顺序性的问题）、
3. 数据一致性问题（发完消息数据库写入失败）。

### 怎样保证MQ消息不丢失
 **1. 生产者弄丢数据：** 
 
生产者发送消息到MQ时，可能数据在网络传输中搞丢了，这时MQ收不到消息，消息就丢了。  

解决方式：
* 事务方式：在生产者发送消息之前开启一个事务，MQ收到了这个消息，再去提交事务，缺点：生产者的吞吐量和性能都会降低。
* confirm机制：生产者每次写消息的时候会分配一个唯一的id，然后RabbitMQ收到之后会回传一个ack，告诉生产者这个消息ok了，
如果MQ没有处理到这个消息，那么就回调接口，这个时候生产者就可以重发。  

事务机制和cnofirm机制最大的不同在于事务机制是同步的，提交一个事务之后会阻塞在那儿，但是confirm机制是异步的，
发送一个消息之后就可以发送下一个消息，然后那个消息MQ接收了之后会异步回调生产者一个接口通知上传者这个消息接收到了。一般都会去使用confirm机制。

 **2. MQ弄丢数据：**   
 
 如果MQ宕机了，这个时候消息就会丢失。   
 
 解决方式： 
 * 持久化机制：消息写入之后会持久化到磁盘。
 * 配合confirm：如果及持久化到磁盘就挂掉了，那么就要配合confirm机制一起来保证的，就是在消息持久化到磁盘之后才会给生产者发送ack消息。  
 
  **3. 消费端弄丢数据：**   
  
  在消费消息的时候，刚拿到消息，结果进程挂了，这个时候MQ就会认为你已经消费成功了，这条数据就丢了。  
  
  解决方式： 
  * 在消费者收到消息的时候，会发送一个ack给MQ，告诉MQ这条消息被消费到了，这样MQ就会把消息删除。
 但是默认情况下这个发送ack的操作是自动提交的，也就是说消费者一收到这个消息就会自动返回ack给MQ，所以会出现丢消息的问题。
所以针对这个问题的解决方案就是：在消费者处理完这条消息之后再手动提交ack。

### 怎么保证MQ的高可用性？
主从+集群
