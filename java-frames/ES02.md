# es 在数据量很大情况下（亿级）如何提高性能
### 一、利用好 filesystem cache
filesystem cache(os cache)，操作系统的缓存 。很多时候数据量大了，特别是有几亿条数据的时候，可能会发现，跑个搜索第一次搜索的时候，是5~10秒，后面反而就快了，可能就几百毫秒，这是为什么呢？
往es里写的数据，实际上都写到磁盘文件里去了，磁盘文件里的数据操作系统会自动将里面的数据缓存到os cache里面去。
es的搜索引擎严重依赖于底层的 filesystem cache，你如果给 filesystem cache 更多的内存，尽量让内存可以容纳所有的 indx segment file 索引数据文件，那么搜索的时候就基本都是走内存的，性能会非常高。  


**走磁盘和走操作系统缓存性能差别非常大**，缓存中没有要查询的数据，那只能去走磁盘了，如果数据量很大走磁盘一般肯定上秒，但是如果是走filesystem cache，由于是纯内存的，
那么一般来说性能比走磁盘要高一个数量级，基本上就是毫秒级的，从几毫秒到几百毫秒不等。

比如说，es节点有3台机器，每台机器，看起来内存很多，64G，总内存：64 * 3 = 192g。每台机器给es jvm heap是32G，那么剩下来留给 filesystem cache 的就是每台机器才32g，
总共集群里给filesystem cache的就是32 * 3 = 96g内存。在3台机器上，一共占用了1T的磁盘容量，也就是说es数据量是1t。
那么十分之一的数据可以放内存，其他的都在磁盘，然后执行搜索操作，大部分操作都是走磁盘，性能肯定差。

归根结底，要让es性能要好，最佳的情况下，**就是机器的操作系统缓存至少可以容纳你的总数据量的一半（官网推荐）**。 

机器的内存总是有限的，如果机器内存放不下全量字段的数据，那么尽量在es里存储必须用来搜索的数据，比如说，就写入es `id name` 等关键字段就可以了，最好是写入es的数据小于等于，或者是略微大于es的filesystem cache的内存容量。
然后把其他的字段数据存在 mysql 里面。
一般是**建议用 es + hbase 架构**。hbase 的特点是适用于海量数据的在线存储，就是对hbase可以写入海量数据，不要做复杂的搜索，就是做很简单的一些根据id或者范围进行查询的这么一个操作就可以了。

### 二、数据预热  
假如按照上述的方案一去做了，但是es集群中每个机器写入的数据量还是超过了filesystem cache一倍，比如说你写入一台机器60g数据，结果filesystem cache就30g，还是有30g数据留在了磁盘上。  
* 比如微博，就可以把一些大v，平时看的人很多的数据给提前你自己后台搞个系统，每隔一会儿，你自己的后台系统去搜索一下热数据，刷到filesystem cache里去，
后面用户实际上来看这个热数据的时候，他们就是直接从内存里搜索了，这样查询速度是很快的。  
* 比如电商，就可以将平时查看最多的一些商品，比如说iphone 12，热数据提前后台搞个程序，每隔1分钟自己主动访问一次，刷到filesystem cache里去。 

对于那些比较热门的经常会有人访问的数据，最好做一个专门的缓存预热子系统，就是对热数据，每隔一段时间，你就提前访问一下，让数据进入filesystem cache里面去。这样下次别人访问的时候，一定性能会好一些。

### 三、冷热分离  
**es 可以做类似于 mysql 的水平拆分**，将大量的访问很少频率很低的冷数据单独写一个索引，然后将访问很频繁的热数据单独写一个索引。
最好是将冷数据写入一个索引中，然后热数据写入另外一个索引中，这样可以确保热数据在被预热之后，尽量留在filesystem os cache里，不会被冷数据给冲刷掉。  

比如：一部分放热数据index；另外一部分机器放冷数据index
* 对于热数据而言，大量的时候是在访问热数据index，热数据可能就占总数据量的10%，此时数据量很少，几乎全都保留在filesystem cache里面了，就可以确保热数据的访问性能是很高的。
* 对于冷数据而言，是在别的index里的，跟热数据index都不再相同的机器上，如果有人访问冷数据，可能大量数据是在磁盘上的，此时性能差点没关系，就10%的人去访问冷数据，90%的人在访问热数据。  

### 四、优化 document 模型设计  
document模型设计是非常重要的，很多操作不要在搜索的时候才想去执行各种复杂的乱七八糟的操作。es能支持的操作就是那么多，不要考虑用es做一些它不好操作的事情。
如果真的有那种操作，尽量在document模型设计的时候，让数据写入的时候就存好复杂数据关系。   

另外对于一些太复杂的操作，比如 `join，nested，parent-child` 搜索都要尽量避免，性能都很差的。  

es能做的操作用es来做，搜索出来数据的复杂处理可以在java程序里面去做，比如基于es去用java封装一些特别复杂的操作。  

### 五、分页性能优化  

es的分页是较坑的。  

举个例子吧，假如每页是10条数据，你现在要查询第100页，实际上 es 会把每个shard上存储的前1000条数据都查出来到一个协调节点上，
如果你有个5个shard，那么就有5000条数据，接着协调节点对这5000条数据进行一些合并、处理，再获取到最终第100页的10条数据。
翻页的时候，翻的越深，每个shard返回的数据就越多，而且协调节点处理的时间越长，这样性能就会越差。所以用es做分页的时候，会发现越翻到后面，就越是慢。  

解决方案：
* 业务上避免深度分页  
* 使用 `scroll api` ，类似于刷微博一样，让用户去一页一页往下拉，不能去随意跳页。  

scroll 的原理实际上是保留一个数据快照，然后在一定时间内，你如果不断的滑动往后翻页的时候，类似于你现在在浏览微博，不断往下刷新翻页。
那么就用scroll不断通过游标获取下一页数据，这个性能是很高的，比es实际翻页要好的多的多。  

但是唯一的缺点就是，scroll 适合于那种类似微博下拉翻页的，不能随意跳到任何一页的场景。
同时这个scroll是要保留一段时间内的数据快照的，你需要确保用户不会持续不断翻页翻几个小时。

