### Dubbo概念 
Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的`RPC`远程服务调用方案，以及`SOA`服务治理方案。
* RPC（Remote Procedure Call）—远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。
比如两个不同的服务 A、B 部署在两台不同的机器上，那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？
使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。
* SOA （Service-Oriented Architecture）,面向服务的架构（SOA）是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，
并通过这些服务之间定义良好的接口和契约联系起来。SOA架构中有两个主要角色：服务提供者（Provider）和服务使用者（Consumer）。  

### Dubbo特性
* **负载均衡**——同一个服务部署在不同的机器时该调用那一台机器上的服务。
* **服务调用链路生成**——随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，Dubbo 可以为我们解决服务之间互相是如何调用的。
* **服务访问压力以及时长统计、资源调度和治理**——基于访问压力实时管理集群容量，提高集群利用率。
* **服务降级**——某个服务挂掉之后调用备用服务。

### 分布式概念
分布式或者说 SOA 分布式重要的就是面向服务，说简单的分布式就是我们把整个系统拆分成不同的服务然后将这些服务放在不同的服务器上减轻单体服务的压力提高并发量和性能。  

从开发角度来讲单体应用的代码都集中在一起，而分布式系统的代码根据业务被拆分。所以，每个团队可以负责一个服务的开发，这样提升了开发效率。另外，代码根据业务拆分之后更加便于维护和扩展。

### Dubbo架构
Dubbo的架构图如图所示： 

![image](https://github.com/islongfei/Blog/blob/master/images/ZooKeeper%E5%8E%9F%E7%90%86.jpg)
* Provider： 暴露服务的服务提供方
* Consumer： 调用远程服务的服务消费方
* Registry： 服务注册与发现的注册中心
* Monitor： 统计服务的调用次数和调用时间的监控中心
* Container： 服务运行容器

调用关系说明：

1. 服务容器负责启动，加载，运行服务提供者。
2. 服务提供者在启动时，向注册中心注册自己提供的服务。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。  

相关机制：
* 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小
* 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示
* 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外
* 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者
* 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表
* 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者
* 服务提供者无状态，任意一台宕掉后，不影响使用
* 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复  

### 负载均衡策略
在集群负载均衡时，Dubbo 提供了多种均衡策略，默认为 random 随机调用，可以自行扩展负载均衡策略。  
#### 1. Random LoadBalance(默认，基于权重的随机负载均衡机制)    

#### 2. RoundRobin LoadBalance(基于权重的轮询负载均衡机制)  

存在问题：提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。所以一般不推荐。  

#### 3. ConsistentHash LoadBalance（一致性hash算法）

一致性Hash，相同参数的请求总是发到同一提供者。一般用于带状态的服务，比如当某一个请求第一次触发时会将该请求相关数据集缓存到内存中，而这个加载和内存都有一定的时间/空间开销，那么下一次当同样一个请求（比如请求参数相同）触发到集群处理的时候，往往希望使用上一次处理的服务器来处理同一笔请求，这样之前缓存的状态数据就可以复用了。  

当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。

#### 4. LeastActive LoadBalance（最小活跃调用算法）  

使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。如果使用轮询算法，那么高、低配置的服务器总是处理相同的任务请求，造成高配服务器闲置资源浪费，而使用最小活跃调用算法则可以更好的避免该问题。

#### 策略的配置方式
* xml配置：`<dubbo:service interface="..." loadbalance="roundrobin" />`，
在暴露duubo接口的配置方式中加上例如： `loadbalance="roundrobin`"属性即可。  

* 注解配置方式：消费方基于基于注解的服务级别配置方式,如下所示：
  ```
  @Reference(loadbalance = "roundrobin")
  HelloService helloService;
  ```
 
### Zookeeper宕机与Dubbo直连
在实际生产中，假如zookeeper注册中心宕掉，一段时间内服务消费方还是能够调用提供方的服务的，实际上它使用的本地缓存进行通讯，这只是dubbo健壮性的一种提现。
#### Dubbo的健壮性表现：
1. 监控中心宕掉不影响使用，只是丢失部分采样数据
2. 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
3. 注册中心对等集群，任意一台宕掉后，将自动切换到另一台
4. 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯
5. 服务提供者无状态，任意一台宕掉后，不影响使用
6. 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复

#### Dubbo直连
注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小。所以，可以完全可以绕过注册中心——采用 dubbo 直连 ，即在服务消费方配置服务提供方的位置信息。
配置方式如下所示：
* xml配置
```xml
<dubbo:reference id="userService" interface="com.xxx.service.UserService" url="dubbo://localhost:20880" />
```
* 注解方式
```Java
 @Reference(url = "127.0.0.1:20880")   
 HelloService helloService;
 ```




