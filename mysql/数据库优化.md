### SQL优化
1. **分页查询优化**
* 使用子查询优化分页查询，提前对 id 或其他索引筛选，减少查询的数据量；
* 假如id是自增的，可以用 id between ... and ... 来查询，或者用 id in(子查询)，注意 mysql 某些版本不支持在 in 子句中使用 limit ；
* 在一些场景下，比如使用历史表的时候，或者出现过数据缺失问题时，可以考虑使用临时表（temporary）来记录分页；
* 如果分页查询id，可以使用覆盖索引，不用回表，可参考[索引详解-覆盖索引](https://github.com/islongfei/Blog/blob/master/mysql/%E7%B4%A2%E5%BC%95.md)，大大提高性能。

2. **join语句优化**
* 如果使用 join 语句的话，不管被驱动表有没有可用索引，都应用小表做驱动表，具体原因详见[ join 语句的两种算法及使用总结](https://github.com/islongfei/Blog/blob/master/mysql/join%20%E8%AF%AD%E5%8F%A5%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95.md)

3. **避免慢 SQL**    
慢 SQL 原因可能有以下几个方面：  
* 无索引或索引失效；  
* 锁等待问题：  
如果数据库是基于表锁实现，那么有数据更新的时候，就会锁住整张表，大量数据操作（包括查询）会处于等待状态，严重影响并发性能。在 InnoDB 中，
批量更新操作时，行锁就可能升级为表锁。因为 MySQL 认为一张表使用了多个行锁，会是事务执行效率下降，会造成其他事务的锁等待问题，导致性能下降，所以MySQL
会将行锁升级为表锁，如果行锁是基于索引加的锁，如果在更新过程中，条件索引失效，行锁也会升级为表锁。
* 不恰当的 SQL语句。











//Todo...

