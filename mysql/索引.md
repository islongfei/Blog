### 索引的常见模型
* 哈希表：由于不是有序，哈希索引做区间查找很慢，适用于等值查询的场景。  

* 有序数组：用二分法就可以快速查找出数据，时间复杂度O(long(N))，但是插入时非常麻烦，适用于静态存储引擎。  

*  二叉搜索树：每个节点的左儿子小于父节点，父节点又小于右儿子。
时O(log(N))的查询复杂度，更新要保持这棵树是平衡二叉树，时间复杂度也是O(log(N))。其索引不止存在内存中，还要写到磁盘上，如果树高为n，
查询就要访问n个数据块，单独访问一行就需要`n*访问每块数据库的时间`，这是非常慢的。
为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，就不应该使用二叉树，而是要使用N叉树。 

### InnoDB的索引模型 
InnoDB使用B+树索引模型，每一个索引在InnoDB里面对应一棵B+树。
#### 主键索引（聚簇索引）与非主键索引
主键索引的叶子节点存的是整行数据（主键值+其他字段值），非主键索引（二级索引）叶子节点存的是主键值。
#### 主键索引与非主键索引查询区别  
如下所示建一张表：  
```MySQL
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;

```
1. 如果语句是 select * from T where id = 3，即主键查询方式，则只需要搜索id这棵B+树；
2. 如果语句是 select * from T where k = 5，即普通索引查询方式，则需要先搜索k索引树，得到id的值为3，再到id索引树搜索一次。
这个过程称为**回表**。也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询

### 索引维护
B+ 树为了维护索引有序性，插入会引起部分元素的挪动。如果数据页满了，会申请一个新的数据页，然后插入时会挪取部分数据到新的数据页，这件做**页分裂**，
这就使得整体的空间利用率降低50%，如果删除了数据，为保证其利用率，会将原来的数据合并为一页，这叫做**页合并**。  

#### 主键字段的选择
自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。  
有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。   

主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。从性能和存储空间方面考量，自增主键往往是更合理的选择。 

适合业务字段直接做主键的场景：表中只有一个索引，该索引必须是唯一索引。也就是典型的KV场景，由于没有其他索引，就不用考虑其他索引叶子节点大小的问题，
查询的时候也不用回表。  

### 覆盖索引
例如：
```MySQL
select ID from T where k between 3 and 5
```
k为索引，ID为主键，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。
也就是说，在这个查询里面，索引+k+已经“覆盖了”我们的查询需求，我们称为**覆盖索引**。
由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。

### 最左前缀原则
B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。例如有一个联合索引（name,age）,可能需要用name来查找一条记录，就不用再去创建一个name索引了。
最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。  

使用最左前缀的原则：
* 如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。
* 考虑空间：name字段是比age字段大，建议创建一个（name,age)的联合索引和一个(age)的单字段索引。 

### 索引下推
MySQL5.6后引入的索引下推优化（index condition pushdown)，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。








