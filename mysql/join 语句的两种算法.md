**场景**：有一个 t1 表和一个 t2 表，要用两个表中 a 字段进行 join 查询。
### Index Nested-Loop Join (NLJ)
假设 t1 为驱动表（100行数据），t2 为被驱动表（1000行数据），t2 表 a 字段上有索引，那么 NLJ 的过程如下：

1. 对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；
2. 而这 100 行的每一行，是根据 a 去表 t2 查找，走的是索引树。每次的搜索过程都只扫描一行，也就是扫描 t2 100 行；
3. 取出表 t2 中满足条件的行，跟 R 组成一行，作为结果集的一部分，最终返回。

整个执行流程，总扫描行数是 200。    

如果将 t1 作为大表（1000行数据），t2 作为小表（100行数据） ，那么就得扫描1200行数据，并且遍历树的次数增加了10倍。

**NLJ 总结：如果使用 join 语句的话，并且可以用上被驱动表的索引，需要让小表做驱动表**，这样可以减少扫描行数和树的搜索次数，提高 sql 效率。

### Block Nested-Loop Join (BNL)  
被驱动表上没有可用的索引，就用的是 BNL算法，过程如下：  

假设 t1 为驱动表（100行数据），t2 为被驱动表（1000行数据）

1. 把表 t1 的数据读入线程内存 join_buffer 中，表 t1 数据放入内存；
2. 扫描表 t2，把表 t2 中的每一行取出来，跟 join_buffer 中的数据做对比，满足 join 条件的，作为结果集的一部分返回。  

在这个过程中，对表 t1 和 t2 都做了一次全表扫描，因此总的扫描行数是 1100。由于 join_buffer 是以无序数组的方式组织的，
因此对表 t2 中的每一行，都要做 100 次判断，总共需要在内存中做的判断次数是：100*1000=10 万次。  由于10 万次判断是内存操作，速度上会比较快。  

join_buffer 是有大小限制的，如果 join_buffer，一次性放不下读入的数据，就得去`分块 join`,会先将部分数据放入 join_buffer与 t2 作对比，
将满足条件的合并到结果集，然后再清空 join_buffer 后复用，继续从 t1 去放入剩下的数据去对比。  

join_buffer_size 越大，一次可以放入的行越多，分成的段数也就越少，对被驱动表的全表扫描次数就越少。

**BNL 总结：在 join_buffer_size 足够大的时候，是一样的，在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表**。
