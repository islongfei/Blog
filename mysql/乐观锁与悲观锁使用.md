阿里开发手册对乐观锁的使用这样写道：   

`并发修改同一记录时，避免更新丢失，需要加锁，要么在应用层加锁，要么在缓存层加锁，
要么在数据库使用乐观锁，使用version作为更新依据。`   

`【说明】如果每次访问冲突的概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次`  

在不使用悲观锁与复杂SQL的前提下，可以使用乐观锁处理并发更新问题，同时兼顾性能，根据阿里巴巴手册可以看到,如果业务的并发很高，乐观锁的重试次数就会很多，
导致性能下降，这时就要使用悲观锁了。    

目前最好的策略就是**先乐观，乐观一定次数失败，再悲观**。这样的策略在 JDK1.7ConcurrentHashMap 的 size 操作中同样有体现，计算 size
时，首先会进行若干次尝试，每次对各个 Segment 的 count 求和,如果任意前后两次求和结果相同，则说明这段时间内各个 Segment 的元素个数没有改变，直接返回求和结果就行了。如果超过一定重试次数（2次）之后，则直接使用 悲观锁 lock锁住各个 Segment，再次求和。  

**注意：** 在处理资金相关金融敏感信息，使用悲观锁比较合适。因为乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，而且乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常。

**总结：** 先乐观再悲观这种操作固然牛逼，但是开发水平如果不是非常牛逼，并且做的业务又比较敏感重要，就别瞎搞，选择悲观锁策略才是比较适合的。


