### 一条查询sql如何执行
1. **连接器**：根据ip+端口+用户名+密码进行与 mysql 连接。
2. **查询缓存**：如果之前执行过相同的查询语句且表没有被更新情况下，之前查询的结果是以 key-value 的形式存在内存中的。
除非表中的数据基本一直保持不变，才适合使用查询缓存。mysql8.0 已经将查询缓存的功能删除掉了。
3. **分析器**：分析语法，解析关键字，如果 sql 语法不对，就会报出相关错误。
4. **优化器**：比如表中有多个索引，优化器先会选择执行哪个索引，以及有连接语句时优化各个表的连接顺序等。
5. **执行器**：先判断对这个表有没有执行权限，有权限就会使用对象的引擎接口，然后会逐行扫描表，将满足的数据依次放进结果集中，之后返回给客户端。

### 一条更新sql如何执行
流程与查询sql一样，只是还涉及到了两个日志模块。  

### redo log  
如果每一次的更新操作都要写进磁盘并更新，那么整个IO成本和查找成本都会很高，
为了解决这个问题 ，mysql 使用了 WAL(Write-Ahead Logging) 技术,就是先写redo log日志，等系统不忙得时候再写磁盘。    

如果写进redo log的数据非常多时，redo log被记录满了，就会在更新前擦除之前最先的数据（checkpoint时擦除的边界）。  

有了 redo log 即使数据库发生异常重启，之前提交的记录也不会丢失，这个能力称为     crash-safe

### binlog
* binlog 是InnoDB引擎特有的日志。
* redo log 是物理日志，binlog 是逻辑日志，记录的是语句的原始逻辑。
* redo log 是循环写的，binlog 是追加写的，binlog文件写满了会切换到下一个，不会覆盖之前的日志。  
* 通过定期进行 redo log 备份，可以在误删表之后找回数据。

### 两阶段提交
数据更新到内存中后会执行这样的日志顺序：
1. 写入redolog,处于prepare阶段
2. 写入binlog
3. 将redolog改为commit状态  

两阶段提交目的为了保持两份日志的逻辑一致，防止用日志出来的库状态不一致。  
在增加从库来提升系统都能力时，通常采用全量备份+binlog 来实现的，如果没有两段提交，就可能会出现主从不一致。

