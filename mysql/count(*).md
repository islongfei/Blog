在开发系统的时候，需要计算一个表的行数，这时候你可能会想，一条 select count(* ) from t 语句不就解决了吗？
但是， 会发现随着系统中记录数越来越多，这条语句执行得也会越来越慢。  下面来看一下 count(*) 的实现方式。  

### count(*) 的实现方式  
* MyISAM 引擎把一个表的总行数存在了磁盘上，执行 count(*) 的时会直接返回这个数，效率很高（无 where 条件下）；
* 而 InnoDB 中，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

#### 为什么 InnoDB 没有把行数存起来呢？

因为，即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表 返回的行数也是不确定的。
这和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别（别人改数据的事务已经提交，我在我的事务中也不去读）。  

#### 为什么不用 show table status 来查看表行数？  

 使用 `show table status` 命令的话，就会发现这个命令的输出结果里面也有一个 TABLE_ROWS 用于显示这个表当前有多少行，这个命令执行挺快的,为什么不用呢？
 因为TABLE_ROWS 是通过采样估算得来的，因此它也很不准（官方文档说误差可能达到 40% 到 50%）。   
 
 ### 不同 count 用法效率分析  
 
 在 InnoDB 中 count(*)、count(主键 id)、count(字段) 和 count(1) 等不同用法的性能，有哪些差别呢？  
 
 * `count(主键 id)` ：InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
 
 * `count(1)` ：InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字 “1” 进去，判断是不可能为空的，按行累加。  
 
所以， count(1) 执行得要比 count(主键 id) 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作 。（PS: 自己发现一些公众号关于这方面的结论是错的，真是假酒害人呐！:unamused:）

* `count(字段）`: 行地从记录里面读出这个字段，判断不能为 null，按行累加。   

* `count(*) `: count(* )并不会把全部字段取出来，而是专门做了优化，不取值,count(*) 按行累加。    

总结：count(字段)<count(主键 id)<count(1)≈count(* )，所以尽量用count(*)。  

### 表中行数太多，count(*)很慢怎么办？  
* 有数据库单独一个表来保存计数。
