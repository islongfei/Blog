## 分布式锁

#### 为什么要使用分布式锁
在多线程并发的情况下，可以使用同步锁或 Lock 锁来保证在同一时间内，只能有一个线程修改共享变量或执行代码块。
但现在服务基本都是基于分布式集群来实现部署的，对于一些共享资源在分布式环境下使用 Java 锁的方式就失去作用了。
所以需要分布式锁机制来保证在一个集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。
#### 分布式锁服务的特点
* 机器互斥性：在任意时刻，只有一个客户端可以获得锁，这是 CAS 所做不到的。
* 避免死锁：获取锁之后最终一定要去释放锁，要考虑系统崩溃、网络异常等情况。
* 容错性：锁服务集群中只要只要大部分节点可用，就可以正常进行加锁解锁操作。
#### 设计重点
* 如果锁进程挂掉，锁没有归还回来，造成死锁怎么办？设置锁过期时间： Redis 设置超时时间、zk 可以设置 sessionTimeout。
* 如果意外自动解锁，新的进程拿到了锁，之前的进程以为自己还有锁，数据更新错乱怎么办？使用 CAS。
#### 业界的分布式锁
* Chubby：Google 的一个粗粒度分布锁的服务，但不是开源，很难了解其中具体细节。
* Redis：可以使用开源 redisson 的 jar 包。
* ZooKeeper：可以使用开源的curator的jar包。Yahoo也是借鉴了 Chubby 的设计思想开发了zookeeper，并将其开源。
* Tair：是阿里开源的一个分布式K-V存储方案，不过工作中一般用Redis ZooKeeper 比较多，所以 Tair 并没有被广泛使用。
* 数据库分布式锁：存在很大的性能瓶颈，一般很少用。  

下面来说一下三种常见的分布式锁方案：
## Redis 分布式锁
可以通过下面命令进行加锁：   
`SET key  value NX PX  30000`  
#### 说明：
* set nx命令只会在key不存在时去赋值 ，px命令表示key存活时间，单位为 ms。
* value 必须是全局唯一的值，value 可以 /dev/urandom 中取 20 个 byte 作为随机数(官方推荐)，也可以使用时间戳+客户端编号（适应绝大多数场景）。
* 客户端只会解锁自己曾经加过的锁（通过判断key）。
#### 原理：
只有在某个 key 不存在的情况下才能设置（set）成功该 key。多个进程并发去设置同一个 key，只有一个进程能设置成功，
而其它的进程因为之前有进程把 key 设置成功了，会获取锁失败。
#### 可能出现的问题：
`问题 1`：  
客户端 A 获取锁之后，刚好 A 碰见了异常情况：一个外部阻塞调用、CPU 被别的进程吃满、刚好碰到了 full GC STW，常用的 
[ CMS 和 G1 垃圾回收器 都会发生 STW](https://github.com/islongfei/Blog/blob/master/java-basics/CMS%20%E5%92%8C%20G1%20%E7%9A%84%E5%8C%BA%E5%88%AB.md)，
导致 A 花费了超过平时好几倍的时间，锁服务为了防止死锁通常会把这个锁释放掉，此时 B 获得了锁并更新了资源，之后 A 缓过来了，也去更新了资源，这就造成了数据出错。

 **解决方案**： 采用乐观锁的思想，加一个版本号去判断。  
 
 `问题 2`：  
如果是在 Redis 集群环境下，由于 Redis 集群数据同步到各个节点时是异步的，如果在 Master 节点获取到锁后，
在没有同步到其它节点时，Master 节点崩溃，slave 来不及同步数据就被选为 Master，从而数据丢失。  

**解决方案**：Redisson（是基于 netty 通信框架实现的，所以支持非阻塞通信，性能比 Jedis 好）的 Redlock 算法。 

**Redlock**: 在不同的节点上使用单个实例去获取锁，每次获取锁都有超时时间，如果超时则认为节点不可用，
当成功获取锁的节点超过半数，且获取锁的时间不超过锁过期时间，则表示获取锁成功。
如果获取锁成功，就会重新计算释放锁的时间，该时间是由原来释放锁的时间减去获取锁所消耗的时间；而如果获取锁失败，客户端依然会在 Master 释放获取锁成功的节点。  

`问题 3`：
**redlock存在问题**：节点崩溃重启，会出现多个客户端持有锁。  

假设一共有5个Redis节点：A, B, C, D, E。设想发生了如下的事件序列：
1. 客户端1成功锁住了A, B, C，获取锁成功（但D和E没有锁住）。
2. 节点C崩溃重启了，但客户端1在C上加的锁没有持久化下来，丢失了。
3. 节点C重启后，客户端2锁住了C, D, E，获取锁成功。
这样，客户端1和客户端2同时获得了锁（针对同一资源）。  

**解决方案**：延迟重启，即一个节点崩溃后，先不立即重启它，
而是等待一段时间再重启，使等待的时间大于锁的有效时间。
采用这种方式，这个节点在重启前所参与的锁都会过期，它在重启后就不会对现有的锁造成影响。
## ZooKeeper 分布式锁
利用 [ZooKeeper](https://github.com/islongfei/Blog/blob/master/java-frames/ZooKeeper.md) 的顺序临时节点和 Watch 机制：
* **顺序临时节点**： ZooKeeper 节点类型分为持久节点、临时节点，节点可以被标记为有序性，创建一个持久节点为父节点，在父节点创建临时节点，并标记临时节点为有序性，那么整个节点会具有顺序递增的特点。  
* **Watch机制**：ZooKeeper 允许用户在指定节点上注册一些 Watcher（事件监听器），并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知给用户。
#### 原理：
建立一个父节点为持久节点，每当访问共享资源时，就添加一个顺序子节点，并标记为有序。
如果刚刚建立的子节点是最小节点则获取锁，如果不是则阻塞等待锁，并获得上一个顺序节点，为其注册监听事件，等待前面操作完获取锁。调用共享资源结束后，删除该节点，触发监听时间，释放该锁。
#### 存在问题：
当某个客户端发生 STW 的时候，zookeeper检测不到心跳，也是有可能出现多个客户端同时操作共享资源的情形。  
**解决方案**: 可以通过JVM调优，避免GC停顿出现,但是无法完全消除这一问题。
#### 优点：
ZooKeeper 是集群实现具有很强的高可用性，可以避免单点问题，zookeeper如果长时间检测不到客户端的心跳的时候，就会认为Session过期了，
一旦服务挂掉，临时节点会因为session连接断开而自动删除，可以有效地释放锁。
#### 缺点：
如果频繁的创建、删除节点和大量的 watch 事件，会使集群压力会非常大。

## 数据库分布式锁
数据库实现分布式锁是最简单的一种方式。
#### 乐观锁方式：
可以创建一个锁表：
```Mysql
CREATE TABLE `optimistic_lock` (
	`id` BIGINT NOT NULL AUTO_INCREMENT,
	`resource` int NOT NULL COMMENT '锁定的资源',
	`version` int NOT NULL COMMENT '版本信息',
	`created_at` datetime COMMENT '创建时间',
	`updated_at` datetime COMMENT '更新时间',
	`deleted_at` datetime COMMENT '删除时间', 
	PRIMARY KEY (`id`),
	UNIQUE KEY `uiq_idx_resource` (`resource`) 
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='数据库分布式锁表';
```
每当更新完成时，会对版本号加1。在更新过程中，会对版本号进行比较，如果与期望的版本号是一致的，则会成功执行本次操作；如果版本号不一致，则会更新失败。
乐观锁的思想和 CAS 是十分相似的。
#### 缺点：
当应用并发量高的时候，version 值在频繁变化，不会像java锁乐观锁重试一定次数后升级为悲观锁，会导致大量请求失败，影响系统的可用性，得不偿失。

#### 悲观锁方式：
`select ... for update`的方式，要保证查询和插入是在同一个事务中。
#### 缺点：
 RR （可重复读）事务级别中，select 的 for update 操作是基于间隙锁 gap lock 实现的，这是一种悲观锁的实现方式，所以存在阻塞问题，存在很大的性能瓶颈。
 
## 总结
不到万不得已，不要用分布式锁，不然系统整体性能会影响很多，如果需要使用分布式锁，就要考虑哪种方式是最适合的。   
Redis 的性能是最好的，Zookeeper 次之，数据库最差。虽然 zookeeper 读写性能不如 redis，存在着性能瓶颈，但是zookeeper 的分布式锁的可靠性比 redis 强很多。如果对性能要求不是特别高，zookeeper 的分布式锁是最适合的。


