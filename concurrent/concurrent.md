## 基础概念
* 启动线程的三种方式：Thread Runnable 线程池
* sleep、yield(进入等待队列里)让出一下cpu、join(加入线程)用来等待另一个线程结束
* synchronized 需要拿到这把锁才能执行synchronized修饰的代码（对象），
对象头会有两位记录锁的信息，this(指的是当前对象)
* 可重入：一个同步方法调用另外一个同步方法，一个线程已拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。
* 产生异常，锁将被释放，其他线程就会冲进来，想让不被释放，可以进行catch

### synchronized的底层实现  
* jdk 早期的实现是重量级的（都要去os申请锁）
* 后来改进为锁升级（我就是厕所所长12 马士兵），第一个线程访问 给markword
记录这个线程的id(偏向锁)，但是不去加锁，如果第二次还是这个线程访问，只判断下markword
的线程id即可，访问效率很高。如果有线程争用，升级为自旋锁（在马桶外面转圈等）。
自旋一定次数后（在用户态去做），升级为重量锁，去操作系统申请锁（切换为内核态），
外面的线程为等待状态，不去自旋了，也不去占用cpu了。
加锁代码执行时间长或者线程数很多，尽量去使用系统锁（重量级锁），减少自旋cpu空转。反之用自旋锁。
* 操作系统锁的实现方式？
* synchronize(Object),只能锁对象，不能使用String常量 Integer Long等
* 锁的是当前对象而不是代码，锁方法，锁的是this,如果是static修饰的，锁的是.class

### volatile  
* 连 讲lombda  
* 保证线程可见性，禁止指令重排
* `MESI` cpu缓存一致性协议，多个线程运行在不同cpu上。硬件实现可见性
* 加锁的方法和不加锁的方法，多线程是可以同时访问的  
### 锁优化
* 锁粒度：锁细化（不要去锁不必要的代码），锁粗化（细锁太多，就用一把大锁修饰，减少竞争）
### cas  
* cas 是cpu级别的原语支持
* ABA:线程1：把1变为2，线程2 把1变为2又变为1。在加一个维度去判断（版本号或时间）。aba在基本类型上不影响，但是Object对象 会产生问题：内存的引用地址没变，但是对象的某些属性变了，对象是期望的对象，但是属性不是原来期望对象的属性。
* Unsafe类：atomic类的cas操作都是 unsafe类实现的。new不了，单例实现的，getUnsafe直接去使用（jdk11），以前是通过反射才能使用。新版本使用weak CAS，弱指针方便垃圾回收。
unsafe可以直接操作jvm中的内存，操作内存中的类或实例的变量属性，不用去new对象去操作了，具备了C++写程序操作内存的能力。
* AtomicLong LongAdder（快）:LongAdder分段锁实现，把总线程分为多个部分，去分段锁数组中的元素，也是基于cas操作，最后再把所有的数加起来得到最终结果，在并发线程特别多的时候，优势极大
### ReentrantLock  
* 手动解锁，try finally里释放



































































































