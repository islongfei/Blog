## 基础概念
* 启动线程的三种方式：Thread Runnable 线程池
* sleep、yield(进入等待队列里)让出一下cpu、join(加入线程)用来等待另一个线程结束
* synchronized 需要拿到这把锁才能执行synchronized修饰的代码（对象），
对象头会有两位记录锁的信息，this(指的是当前对象)
* 可重入：一个同步方法调用另外一个同步方法，一个线程已拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁。
* 产生异常，锁将被释放，其他线程就会冲进来，想让不被释放，可以进行catch

### synchronized的底层实现  
* jdk 早期的实现是重量级的（都要去os申请锁）
* 后来改进为锁升级（我就是厕所所长12 马士兵），第一个线程访问 给markword
记录这个线程的id(偏向锁)，但是不去加锁，如果第二次还是这个线程访问，只判断下markword
的线程id即可，访问效率很高。如果有线程争用，升级为自旋锁（在马桶外面转圈等）。
自旋一定次数后（在用户态去做），升级为重量锁，去操作系统申请锁（切换为内核态），
外面的线程为等待状态，不去自旋了，也不去占用cpu了。
加锁代码执行时间长或者线程数很多，尽量去使用系统锁（重量级锁），减少自旋cpu空转。反之用自旋锁。
* 操作系统锁的实现方式？
