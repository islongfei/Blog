### 20200908
* 要往上走需要了解项目所有业务，不能局限于一个模块
### 20200917
* 工作中从更高层次去思考，从领导从公司的角度去考虑
* 思考事情以及推动事情以同理心、利他去出发
* 元认知
* 正确认识公司，看到不顺眼的地方（机会），这才是能体现你价值的时候
* 拒绝简单任务对的诱惑
* 懂得人性，顺应人性
* 不要相信人，要相信人性
### 20201020   
00.23
### 20201026  
* 重点岗位：1对1招聘要求改简历  
* 了解jd业务背后的技术和场景   
* 项目哪些地方可以沉淀  
* 不能等准备100% 才去投简历，要去争取，万一成功了呢  
* 脸皮变厚，提问题要从老板的角度去提
* 公司给我工作是1，我做到3    
* 6+2：jvm 多线程 设计模式 redis zk mysql调优+ 网约车 亿计流量   
* 面试造火箭是因为应聘的人太多，需要筛选    
* 离职原理：原来公司很好，我也在重要岗位上，我就是想进大厂  
* 面试机会只跟简历有关系，站在对方角度看问题    
* 照片：别人看到你照片，就愿意和你见面，（亲和力）  
* `简历模板找班主任要`  
* 投简历的时间最好是每天早上8-10点  
* 打招呼：言简意赅  
* 穿着：阳光大男孩，干净整洁  
* 面试官见你第一眼，50%就确定过不过了，管理好个人形象身材   
* 眼神要坚定 自信  
* 接到面试通知。对方问一周能不能入职，直接说没问题  
* argue工资时，不要带傲气，个人更倾向于这边，看咱们这边offer能不能提提。  

### 20201027  
* 证实自己的获奖经历，上链接  
* 精通这个词简历可以用，60分要写80分  
### 20201102  
* 工作经历按时间逆序  
* 任何项目都可以写jvm调优 sql优化  
* 内部系统可以优化对外连接 对接的点
* 准备几个面试官不知道的业务名词，突出专业  
* 介绍技术架构： 软件架构（分了几层） 硬件架构（多少服务器，配置 linux版本）  
* 项目其中的角色（一定说成是重要模块的核心程序员）  
* 负责的模块（出彩的地方）  
* 并发量（单机QPS TPS）
* 对架构的思考  
* 有什么问题要问我的，业务线，招人的组，整理下脉脉截图，笔记
* 我了解过贵公司，然后引出问题  
* 电话面试录音，晋升路线不要问，hr可能不了解部门内的，问leader  
### 20201103  
* 说一个技术的时候，最好连带说出应用场景，优缺点，举例画图
* 讲述只是的方式尽量和别人不一样  
* 问一个知识点可以把相关技术点都说出来  
* **面试是表现自己，不是考试**  

### 20201109 （操作系统） 
* cpu的原理：计算机需要解决最根本的问题：如何用机器代表数字。用电代表数字，晶体管。
逻辑开关，通电代表1不通电代表0，内存存储电信号，和cpu相连接，cpu读取电信号去做计算。
64位，指的是cpu一次可以读入64位数字。
* 高级语言->编译器->机器语言  
* 汇编语言执行过程：汇编语言的本质：机器语言助记符。用标识去代替特点的100110，更加方便。 
* 量子计算机：量子比特：一个bit可用同时为1和0，1和0同时存在，普通的比特只能为1或0中的一个。
比如：18bit只能代表2^18中的一个数，要猜一个数，普通的比特只能一个一个数去猜，18位量子比特可以瞬间破解2^18个数。

### 20201114  
* 超线程：一个ALU对应多个Registers，所谓四核八线程
* 为什么需要缓存:cpu速度太快，内存速度太慢   
* 数据都是按块读取，充分发挥总线CPU针脚一次性读取更多数据的能力。提高效率  
* 为什么不把数据全装进cpu，这样就更快了：装不下，成本太高
* l1 l2 l3 缓存怎么去同步的：`缓存一致性协议`（intel 使用MESI协议：用四种状态去标记缓存）
* 锁总线：当数据太大无法缓存，或者跨越多个缓存行去读数据时，cpu独占的去读取数据 
* **缓存行**大小：缓存行越大，局部空间效率越高，但读取时间慢。反之则读取时间快，经过多次实践，取了一个折中的方案，取为64字节
* 缓存行对齐：对于有些特别敏感的数字，会存在线程高竞争的访问，为了保证不发生伪共享，可以使用缓存行对齐的方式。多线程访问同一缓存行数据，涉及到缓存的一致性同步问题，效率较低。多线程分开缓存行去访问各自的数据，这样更快。
* jdk 8 加了`@Contended`：使用此注解（需要设置 -XX:-RestrictContended JVM参数才会生效），可以让修饰成员变量，让此变量不是位于同一缓存行，访问效率会更高。
jdk 7 中很多采用了long类型补齐的方式提高效率。
* CPU的乱序执行：其实是为了提高效率，在指令没有依赖关系时，没有按顺序顺序执行而是同时执行
* cpu 如何禁止指令重排:内存屏障：再对内存操作时前后添加屏障，屏障前后的操作不可乱序执行。 实现： intel->汇编原语（mfence ifence sfence）或者锁总线实现。
* JVM内存屏障（是JVM层级的规范）JSR,在写操作和读操作前后都加内存屏障。volatile 修饰对象，是给new出来对象的内存空间前后加屏障。
* JVM层级规定8条必须遵守指令重排的happens-before规则  
* Write Combining Buffer(WC) cpu合并写技术:由于ALU速度太快，为了提高效率，cpu在写入l1时，同时WC写入l2。
* UMA:多个cpu通过同一总线共享内存，缺点：不易扩展，cpu增多后会使内存访问冲突加剧，同城4颗比较合适。所以新的计算机会采用NUMA架构。
* NUMA（Non Uniform Memory Access）:非统一访问总线，访问离自己近的快，对与访问离自己近的内存是有优先级的。ZGC 能感知到哪个内存离自己进，分配内存会优先分类该线程所在cpu的最近内存上。
* 操作系统：管理硬件（内存 硬盘 cpu）、管理应用（进程）
* kernel(内核)：管理内存 cpu 文件系统 进程调度，中断处理，驱动管理。宏内核（一般电脑）：这些东西全部放一起。微内核（鸿蒙）：这些东西放在别的地方，通过网络等访问和调度。 
* CPU-CPL-> 0 1 2 3 四个硬件级别的指令级别，linux(0内核态，3用户态)，linux跑在ring 0级，用户程序跑在ring 3级。
，linux内存分为内核空间和用户空间。
### 20201115
* **进程 线程 纤程**:
* 进程和线程的区别：进程是os用来分配资源的基本单位，线程是os执行调度的基本单位。分配资源最重要的是：独立的内存空间，线程调度执行。线程共享进程的内存空间，没有自己独立的内存空间。线程高层面的理解：一个进程中不同的执行路线。
* 纤程（协程）：用户空间的一个线程 用户态的线程，在一个线程内部再去分别不同的线程，不用和操作系统内核打交道，不用去切换用户态内核态。优势：占有资源很少，os起一个线程要用1M空间，一个纤程(Fiber) 只需要4K。
用户态的，切换比较简单。go语言内置纤程。java openjdk loom类库支持纤程，但是还不成熟，没有合并到jdk主分支上。
* 纤程的应用场景：很多的计算任务，不需要和内核打交道，适合高并发

### 20201116  
* 进程：linux中也称为task，是系统分配资源的基本单位，进程描述符：PCB(Process Control Block)，每一个进程都有一个pcb（内核数据结构），linux在管理进程的时候会把相应信息记录在pcb中，pcb大小不是固定的，每个进程的pcb都不一样。
* 内核线程：内核启动之后经常需要做一些后台操作（清理垃圾等），只在内核空间运行，内核独用的线程。  
* 进程创建和启动：通过系统函数 fork() exec()，从A frok B ，A称作B的父进程.
* 僵尸进程：父进程产生子进程后，会维护子进程的一个pcb结构，子进程退出时由父进程释放pcb，如果父进程没有释放，那么子进程会成为一个僵尸进程。
`ps -ef|grep defunct`  
* 孤儿进程：在子进程结束之前，父进程已经退出了。孤儿进程会成为init进程的孩子，由此线程(1)去维护。
* 进程调度：内核进程调度器决定：该哪一个进程运行，什么时候运行，运行多长时间。抢占式任务调度 非抢占式任务调度（不退出则一直运行），linux2.6.23采用CFS完全公平调度算法。进程类型：IO密集型 大部分时间用于等待IO,CPU密集型 大部分时间用于闷头计算。进程优先级：实时进程（急诊）>普通进程。`linux默认的调度策略`：对于实时进程使用SCHED_FIFO（按优先级顺序执行） 和SCHED_RR（轮询，同级别的FIFO的平均分配）两种，对应普通进程使用CFS。  
* 中断：软件或硬件与操作系统内核通信的一种机制，中断分为硬中断（来源于键盘等硬件）和软中断（软件与内核交互）16进制的0x80。急事处理的一种机制。
### 20201124 
* 一个程序的运行过程，要么处于用户态，要么处于内核态
* DOS时代，同一时间只能有一个进程运行（也有一些特殊算法可以支持多进程）
* window9x，内存变大，多个进程装入内存。1如果不做控制容易把内存撑爆，2互相打扰，为了解决这两个问题，诞生了现在的内存管理系统：虚拟地址，分页装入，软硬件结合寻址。
* 解决内存撑爆：分块装入页框中，内存分页（4k标准页），把程序（硬盘上）分成4k大小的块，用到那一块，就加载那一块。内存满了，进行交换分区（LRU算法），把最不常用的内存放到swap区，把最新的一块加载进来。
* LRU(lc146)，最不常用，哈希表（查找O(1)）+链表(排序和新增O（1）)。双向链表保证左边指针指向右边块。
* 解决相互打扰：虚拟内存，程序中用到的空间地址不在是物理地址而是虚拟地址，这样，A进程永远不可能访问你到B进程的空间。虚拟空间多大？看寻址空间(64位系统 2^64 位，单位byte)，比物理空间大很多,站在虚拟的角度，进程是独享整个系统。虚拟内存通过操作系统映射到物理内存，保护物理内存，不被恶意程序访问。
* 内存映射：偏移量+段的基地址 = 线性地址（虚拟空间）
* 线性地址 通过os + MMU(硬件)来映射正真的物理地址
* 缺页中断：需要用到的页面内存中没有，产生缺页异常（中断），由内核处理并加载。
* **ZGC**：colored pointer算法：gc信息记录在指针上，不是记录在头部。对象死亡，内存立即就可以重用，只需改指针。zgc 64位，42位用在指针。寻址空间 4T,jdk13 ->16T,目前最大是16T。
* cpu 如何区分立即数和一条指令，看是从哪条总线过来的。总线内部分为：数据总线 地址总线 控制总线。目前的地址总线是 48位，所以zgc最大寻址空间位16T
* 颜色指针本质上包含了地址映射的概念













































































