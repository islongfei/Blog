### 什么是线程？
线程是系统调度的最小单元，一个进程可以包含多个线程，作为任务的真正运作者，有自己的栈（Stack）、寄存器（Register）、本地存储（Thread+Local）等
，但是会和进程内其他线程共享文件描述符、虚拟地址空间等。

### 线程生命周期
关于线程生命周期的不同状态，在Java5以后，线程状态被明确定义在其公共内部枚举类型java.lang.Thread.State中，分别是：
* 新建（NEW），表示线程被创建出来还没真正启动的状态
* 就绪（RUNNABLE），表示该线程已经在JVM中执行，当然由于执行需要计算资源，它可能是正在运行，也可能还在等待系统分配给它CPU片段，在就绪队列里面排队。
* 阻塞（BLOCKED），阻塞表示线程在等待Monitor lock。比如，线程试图通过synchronized去获取某个锁，但是其他线程已经独占了，那么当前线程就会处于阻塞状态。
* 等待（WAITING），表示正在等待其他线程采取某些操作。一个常见的场景是类似生产者消费者模式，发现任务条件尚未满足，就让当前消费者线程等待（wait），
另外的生产者线程去准备任务数据，然后通过类似notify等动作，通知消费线程可以继续工作了。Thread.join() 也会令线程进入等待状态。
* 计时等待（TIMED_WAIT），其进入条件和等待状态类似，但是调用的是存在超时条件的方法，比如wait或join等方法的指定超时版本。
* 终止（TERMINATED），不管是意外退出还是正常执行结束，线程已经完成使命，终止运行，也可以把这个状态叫作死亡。  

状态之间的转移图如下所示：
![image](https://github.com/islongfei/Blog/blob/master/images/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E5%9B%BE.png)

### 守护线程
有的时候应用中需要一个长期驻留的服务程序，但是不希望其影响应用退出，就可以将其设置为守护线程，如果JVM发现只有守护线程存在时，将结束进程。
创建守护线程代码如下所示：
```Java
Thread daemonThread = new Thread();
daemonThread.setDaemon(true);
daemonThread.start();

```
