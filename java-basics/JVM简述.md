 ### jvm运行时数据区域  
 
* 方法区：存加载的类信息、常量、静态变量（线程共享）。
* 虚拟机栈：基本类型数据、对象的引用。
* 本地方法栈：为Native方法服务。
* 堆：存放对象实例（线程共享）。
* 程序计数器：执行字节码指令（线程私有）。

### jvm对象的创建
1. 在常量池检查是否有引用
2. 检查这个引用的类是否被加载、解析、初始化过。
3. 在堆中为对象分配内存（指针碰撞、空闲列表）。  

`指针碰撞`：所有用过的内存放一边，空闲的内存放一边，中间放这一个指针作为分界点的指示器，分配内存就是把指针向空闲空间挪动一段与对象大小相等的距离。  

`空闲列表`：如果Java堆中的内存不是规整的，已使用的内存与空闲内存相互交错，就没有办法简单的进行指针碰撞了。jvm就必须维护一个列表，记录哪些内存块是可用的，
在分配的时候从列表中找到足够大的空间划分给对象实例，并更新列表上的记录，这叫就空间列表法。  

### jvm对象的布局
对象在内存存储的布局可分为三个区域：
* 对象头（Header）包括:  
1. 运行时数据：哈希码（虚拟出来的内存地址）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳。
2. 类型指针：对象指向它的类元数据的指针，jvm通过这个指针确定这个对象是哪个类的实列。
* 实例数据（Instance Data）:对象真正储存的有效信息，是代码中定义各种类型的字段内容。
* 对齐填充（Padding）:没有特别的含义，仅仅其占位符的作用，HotSpot VM要求对象的大小必须是8字节的整数倍，当对象实例没有对齐时，就需要对齐填充来补全。

### jvm对象的访问定位
* 句柄访问：堆内存划分一片区域作为句柄池（包含实例数据与类型的地址信息）。
* 直接指针：reference直接存放对象地址。

### GC对象回收
1. 哪些对象需要回收？ 
* `引用计数法`: 在对象中添加一个引用计数器，每当有地方引用它时，计数器就+1，当引用失效时，计数器就-1，计时器为0就会被回收。但是jvm并没有引用这种方法，
因为它很难解决对象相互循环引用的问题（计数器不会为0）。
* `可达性分析算法`: 将GC Roots的对象作为起始点，判断对象到GC Roots的引用链是否可达，如果不可达，则证明这个对象不可用。  

2. 什么时候回收？

  引用（判断对象的存活都与引用有关）：
* 强引用：new对象的代码就是强引用，jvm永远不会回收强引用的对象。
* 软引用：有用但非必须的对象，内存溢出异常之前，就会对这些对象进行二次回收。
* 弱引用：只能生存到下次垃圾回收之前，无论当前内存是否足够，都会回收。
* 虚引用：不会对对象生存时间有影响，目的就是在对象回收时收到一个系统通知。  

3. 如何回收？  

在堆中，新生代：回收一次回收70%-95%空间，而永久代回收效率很低:回收废弃常量（无引用）和无用的类。  

什么才是无用的类？
1. 堆中没有该类的实例，
2. 加载该类的ClassLoader已被回收，
3. 该类对应的java.lang.class对象没有任何地方被引用。  

### 回收算法：
* `标记-清除算法`：标记出所以需要回收的对象然后统一回收。不足：效率不高，空间浪费（回收后产生大量不连续的内存碎片）。
* `复制算法`：将内存划分为相等的两块。每次使用一块，回收时将活者的对象复制到另一块去，再把已使用的内存清理。不足：将内存缩小了一半
* `标记-整理算法`：标记-清除后，让所有存活的对象向另一端移动，然后清理掉边界外的内存。
* `分代回收算法`（jvm所采用的算法）：堆：新生代（每次回收死亡很多，采用复制算法），老年代（对象存活率很高，没有额外空间，采用标记-整理算法）。

### 对象的死亡
1. 如果对象在可达性分析后发现没有和GC Roots相连的引用链，那么对象就会被第一次标记并进项一次筛选，筛选的条件是是否需要执行finalize()方法。如果对象没有覆盖finalize()方法，或finalize()已经被调用过，那么则没有通过筛选，继续生存。  

如果经过了筛选，需要执行finalize()时，那么对象就会进入F-Queue队列中稍后进行回收。如果在这个过程中对象把自己赋值给类变量或对象的成员变量，那么它就会被移出将要回收的集合，继续生存。如果一个对象在finalize()中发生了死循环，那么可能导致内存回收系统崩溃，这个对象将不会被回收。

### 新生代、老年代、永久代关系
为什么要分代？

分代的唯一理由就是优化GC性能。如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用，这样就会对堆的所有区域进行扫描，分代可以减少扫描的内存区域，提高效率。  









