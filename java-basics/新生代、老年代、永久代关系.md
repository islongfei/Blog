### 为什么要分代？
分代的唯一理由就是优化GC性能。如果没有分代，那我们所有的对象都在一块，GC的时候我们要找到哪些对象没用
，这样就会对堆的所有区域进行扫描，分代可以减少扫描的内存区域，提高效率。
### 新生代的GC
HotSpot JVM把年轻代分为了三部分：1个Eden(伊甸园，表示生命的初始)区和2个Survivor(幸存者)区（分别叫from和to）。默认比例为8：1：1。 

新创建的对象会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。  

那么为什么默认比例要设为8：1：1呢？  

因为新生代的对象98%（参考IBM的研究表明）都是朝生夕死的。所以Eden的空间所占比例会很大。由于新生代是用**复制算法**回收的，当进行回收时Eden和Survivor的from区域仍然存活的对象会回到Survivor的为空的to区域中。    

from和同区域是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survivalfrom区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。

空间分配担保:  

当大量对象在Minor GC后仍然存活时（最坏情况是新生代所以对象都存活），就把Survivor无法容纳的对象分给老年代进行分配担保，前提是老年代有足够的剩余空间去做担保。

### 老年代GC
* 长期存活的对象会进入老年代。 
* 大对象直接进入老年代。  

新生代使用Minor GC，老年代则使用Major GC/Full GC，Minor GC速速会比Major GC快10倍以上，因为新生代的回收很频繁。

那么到底什么是**长期存活**呢？  

jvm给每个对象定义了一个年龄计数器，当从Eden经过Minor GC还存活于Survivor中时，此时对象年龄便设为1，此后每次熬过一次Minor GC,年龄便增加一岁，当年龄达到jvm默认的15岁时，对象便会进入老年代。  

可通过`-XX:MaxTenuringThreshold`来自己设置到达老年代的阈值。   

为了更好的适应不同程序的内存情况，jvm还做了优化：如果Survivor空间相同年龄的对象大小总和>Survivor空间的一半，那么>=这个年龄的对象可以直接进入老年代，不会等到默认的15岁。

什么又是**大对象**呢？   

大对象是指需要大量连续内存空间的Java对象，比如长字符串和数组，它们需要的是连续内存空间。因为如果大对象在新生代的话，就会导致内存还有不少空间就得提前回收内存，来保证足够的连续空间来容纳，jvm为了避免这种情况，将大对象放入老年代。

可通过`-XX:PretenureSizeThreshold`来设置直接进入老年代的大对象大小阈值。超过阈值，就会直接进入老年代。

### 永久代
永久代指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。
Class在被加载的时候被放入永久区域。它和和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。

在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。  
原因是为了兼容其他虚拟机（JRockit没有永久代），并且永久代内存经常不够用或发生内存溢出，分配多大空间很难确定（1.7指定的是8M）  
元空间与永久代之间最大的区别在于：元空间并不在虚拟机堆中，而是使用本地内存。

