
### JMM多线程下的问题
Java内存模型简称JMM（Java Memory Model），是Java虚拟机所定义的一种抽象规范，用来屏蔽不同硬件和操作系统的内存访问差异，
让java程序在各种平台下都能达到一致的内存访问效果。   

JMM模型如下所示：  

![image](https://github.com/islongfei/Blog/blob/master/images/JMM.png)  

* 主内存：主内存可以简单理解为计算机当中的内存，主内存被所有的线程所共享，
对于一个共享变量（比如静态变量，或是堆内存中的实例）来说，主内存当中存储了它的“本尊”。  

* 工作内存：工作内存可以简单理解为计算机当中的CPU高速缓存，
每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。  

线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量（直接操作主内存太慢了）。
不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。

如果多个线程对主内存变量操作,前面的线程在工作内存所更新的变量并不会立即同步到主内存，后面的线程可能会读到变量修改前的值，这样就会出现问题。  



### 为什么需要volatile?
为了解决上述问题，可以使用同步锁，但是同步锁对性能的影响太大，所以就需要更轻量级的volatile。  

用volatile修饰的变量保证了对所有线程的**可见性**（当一个线程修改了变量的值，新的值会立刻同步到主内存当中。
而其他线程读取这个变量的时候，也会从主内存中拉取最新的变量值。），volatile的可见性源自于java语言的先行发生原则（happens-before）。

注意volatile只能保证变量的可见性，并不能保证变量的**原子性**（一个操作是不可中断的。即使是多个线程一起执行的时候，一个操作一旦开始，
就不会被其他线程干扰）。  


### volatile特性
* 保证了变量在线程之间的可见性。可见性的保证是基于CPU的内存屏障指令，被JSR-133抽象为happens-before原则。
* 阻止编译时和运行时的指令重排。编译时JVM编译器遵循内存屏障的约束，运行时依靠CPU屏障指令来阻止重排。
* 解决了long类型和double类型数据的8字节赋值问题。  


**8字节赋值问题：**
32位操作系统每次读取最长的是4个字节，32bit，所以，在32位操作系统上,超过32bit的数据是需要分俩次读取的。
那么，在读取long,double类型数据时，有可能在读取第一次时，别的线程对其进行修改，所以才会出现非原子性的操作。  


### 什么时候使用volatile?
* 写入变量不依赖此变量的值，或者只有一个线程修改此变量
* 变量的状态不需要与其它变量共同参与不变约束



### volitale对指令重排的改进
**指令重排**：指令重排是指JVM在编译Java代码的时候，或者CPU在执行JVM字节码的时候，对现有的指令顺序进行重新排序。

指令重排的目的是为了在不改变程序执行结果的前提下，优化程序的运行效率。需要注意的是，这里所说的不改变执行结果，指的是不改变单线程下的程序执行结果，
指令重排是一把双刃剑，虽然优化了程序的执行效率，但在多线程下还是会出现问题。

为了解决指令重排下的问题，jvm使用了**内存屏障**：屏障之前发布的操作被保证在屏障之后发布的操作之前执行。  

当变量被volitale所修饰，在读前后、写前后都会插入相对应的屏障。
