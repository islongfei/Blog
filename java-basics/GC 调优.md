### 垃圾回收器
<img src="https://github.com/islongfei/Blog/blob/master/images/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8.jpg" width="85%" hegiht="85%"  />  

在 JDK1.8 环境下，默认使用的是 Parallel Scavenge（年轻代）+Serial Old（老年代）垃圾回收器，

### GC 的性能衡量指标
* **吞吐量**：GC 的吞吐量：系统总运行时间 = 应用程序耗时 +GC 耗时。如果系统运行了 100 分钟，
GC 耗时 1 分钟，则系统吞吐量为 99%。GC 的吞吐量一般不能低于 95%。
* **停顿时间**：指垃圾回收器正在运行时，应用程序的暂停时间。对于串行回收器而言，停顿时间可能会比较长；而使用并发回收器，
由于垃圾回收器和应用程序交替运行，程序的停顿时间就会变短，但其效率很可能不如独占垃圾回收器，系统的吞吐量也很可能会降低。
* **垃圾回收频率**：通常垃圾回收的频率越低越好，增大堆内存空间可以有效降低垃圾回收发生的频率，但同时也意味着堆积的回收对象越多，
最终也会增加回收时的停顿时间。所以要去适当地增大堆内存空间，保证正常的垃圾回收频率即可。

### 查看 GC 日志  
* 打印 GC 日志  
`-XX:+PrintGC 输出 GC 日志`  
`-XX:+PrintGCDetails 输出 GC 的详细日志`  
`-XX:+PrintGCTimeStamps 输出 GC 的时间戳（以基准时间的形式）`  
`-XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息`  
`-Xloggc:../logs/gc.log 日志文件的输出路径`  

* 利用图形化界面工具查看GC: 如果是长时间的 GC 日志，就很难通过文本形式日志去查看整体的 GC 性能。图形化界面更容易直观排查,
可通过以下两款工具读取GC日志文件来值观显示吞吐量、停顿时间以及 GC 的频率，判断GC性能。
`GCView`  
`GCeasy`

### GC 调优策略
* **降低 Minor GC 频率**  
    通常情况下，由于新生代空间较小，Eden 区很快被填满，就会导致频繁 Minor GC，因此可以通过增大新生代空间，或调整新生代中的比例来降低 Minor GC 的频率。  
单次 Minor GC 时间是由两部分组成：T1（扫描新生代）和 T2（复制存活对象），扩容 Eden 区会使扫描时间增大，但减去了复制存活对象的时间。
通常在虚拟机中，复制对象的成本要远高于扫描成本，在特定情况下（长期存活的对象很多，每次需要复制移动时），扩容是相比比较高效的。  
如果堆中的短期对象很多，那么扩容新生代，单次 Minor GC 时间不会显著增加。

* **降低 Full GC 的频率**  
由于堆内存空间不足或老年代对象太多，会触发 Full GC，频繁的 Full GC 会带来上下文切换，增加系统的性能开销。  
大对象创建会直接进入老年代（可通过 -XX:PretenureSizeThreshold 指定进入老年代大对象的大小），
占用老年代空间，所以应合理减少大对象的创建，可以通过一下方式：  
`在业务上拆解大对象，拆解后进行分配查询或处理`  
`增大堆内存空间，可以设置初始化堆内存为最大堆内存`


* **选择合适的 GC 回收器**
假设业务要求系统相应时间要很快，可以选择响应速度较快的 CMS（Concurrent Mark Sweep）回收器和 G1 回收器，可参考 [CMS 与 G1 区别](https://github.com/islongfei/Blog/blob/master/java-basics/CMS%20%E5%92%8C%20G1%20%E7%9A%84%E5%8C%BA%E5%88%AB.md)。  
而当需求对系统吞吐量有要求时，就可以选择 Parallel Scavenge 回收器来提高系统的吞吐量。  

通常情况，JVM 是默认垃圾回收优化的，在没有性能衡量标准的前提下，尽量避免修改 GC 的一些性能配置参数。
如果一定要改，那就必须基于大量的测试结果来进行调整。

**一个web应用，多久一次Full GC才算正常呢?**    

根据具体的业务来分析，正常小对象且请求平缓的应用服务中，几天一次较为正常。如果有大量大对象创建或者承受高并发场景的服务，Full GC可能会更频繁。

//Todo : jdk各版本选择的垃圾回收器对比及原因


