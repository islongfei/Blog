数组为线性表，且为有连续相等的空间和相同类型的数据。


**数组链表区别？**

链表增删改时间复杂度为O(1),数组根据下标访问为O(1)，所以在不同操作上，各具优势。


**怎样优化数组插入和删除操作？**

数组是连续性的，每次插入和删除可能会使很多元素进行移动，来保证数组的连续性。
如果数组是无序的，可以将元素插入到k位置，再将k位置的元素移到数组元素的最后，这样避免了大规模的元素移动，时间复杂度为O(1)。有序的就得按照规则依次插入了。
如果要删除元素，在一些不要求数组连续性的情况下，可以将多次删除的操作集中在一起。
比如删除数组中非尾部的n个元素，那么可以先把要删除的n个元素标记，当数组没有更多的空间时，这时再将这个n个元素一次性删除，极大减少了数据搬移，jvm中标记-清除算法就是这种思想。


**容器能否完全替换数组？**

使用ArrayList，事先指定大小可以避免很多内存申请和数据搬移的工作，比如：
ArrayList<User> users = new ArrayList(10000)。  
  
ArrayList 无法存储int，long型数据，需要封装成包装类，存在性能消耗。对于基本类型，数组更加合适。


**数组下标为什么是从0开始？**

数组下标从数组的内存模型来讲，确切的应该叫偏移量（offset）
数组的寻址公式为：`a[k]_address = base_address + k * type_size`
base_address 表示首地址，a[k]就表示与首地址偏移了k个type_size的位置。
那么如果数组下标从1开始，寻址公式就会变为`a[k]_address = base_address + (k-1) * type_size`，每次寻址就会多一次减法运算，所以为了把性能优化到极致，故从0开始。
当然下标从0开始也和java的历史有关系，c就是从0开始，java效仿c并沿用了c的习惯。
