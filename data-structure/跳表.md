跳跃表是一种基于有序链表的扩展，简称**跳表**。  

### 跳表的由来
如何快速查找有序链表的某个节点呢？   

可以利用索引的思想，提取链表的关键节点，在查找链表之前，先查找提取出的关键节点，然后缩小范围，进而遍历原链表。  
跳表就是利用这种思想实现，当链表的节点足够多时，可以向更高层继续提取n层节点，保证更高层节点是下层的一半。
节点提取的极限是同一层只有两个节点的时候，因为同一个节点没有比较的意义。

###  新节点的选举
如果大量新节点，经过逐层比较插入到原链表中，上层节点就会变得不够用，这时就需要将新节点提拔到上一层。  

提拔的方式是什么呢？，跳表通过**抛硬币**的随机方式来实现新节点的随机提拔，每次向上提拔的概率是50%。 
因为跳表删除和增加节点是不可预测的，很难用一种有效的方法来保证节点始终均匀分布，
抛硬币方法虽然不能保证绝对均匀分布，但可以保证大体均匀分布。

### 跳表的插入流程
1. 新节点和各层索引节点逐一比较，确定原链表的插入位置。O(logN)
2. 把索引插入到原链表。O(1)
3. 利用抛硬币随机决定新节点是否提升为上一级索引。结果为“正”则提升并继续抛硬币，结果为“负”则停止。O(logN)

总体上，跳跃表插入操作的时间复杂度是O(logN)，而这种数据结构所占空间是2N，既空间复杂度是 O(N)。

### 跳表的删除流程

1. 自上而下，查找第一次出现节点的索引，并逐层找到每一层对应的节点。O(logN)
2. 删除每一层查找到的节点，如果该层只剩下1个节点，删除整个一层（原链表除外）。O(logN)  

总体上，跳跃表删除操作的时间复杂度是O(logN)。

### 跳表与二叉查找树区别
跳表的优点是维持结构平衡的成本比较低，完全依靠随机，而二叉查找树经过多次删除和插入，需要Rebalance来重新调整结构，成本较大。

### 应用场景

* Redis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。
* Lucene, elasticSearch也使用了跳表。

