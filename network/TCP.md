### TCP 特点
* 保证顺序 ，稳重不乱；
* 丢包问题，承诺靠谱；

* 连接维护，有始有终；

* 流量控制，把握分寸；

* 拥塞控制，知进知退。

### TCP 包头格式  
<img src="https://github.com/islongfei/Blog/blob/master/images/TCP%E6%8A%A5%E6%96%87.jpg" width="90%" hegiht="90%"  />

### 三次握手  

三次握手可形象理解为以下情景：  

A：您好，我是 A。

B：您好 A，我是 B。

A：您好 B。    

**为什么必须是三次握手呢？**    

因为三次握手就能确认双方收发功能都正常，缺一不可，双方都得确认对方是否可以收到并能做出应答。 
如果在多一次握手，反倒是有点画蛇添足，反而会增加响应速度。  

三次握手除了双方建立连接外，主要还是为了沟通一件事情，就是 **TCP 包的序号**的问题。    

比如：A 连上 B 之后，发送了 1、2、3 三个包，但是发送 3 的时候，中间丢了，难道又得从头再开始发1 2 3 吗？，如果有序号的话，就可以根据对方告知的包序号，继续从上次有问题的地方接着发送，避免从头再发送。  
TCP每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个 32 位的计数器，每 4ms 加一。

### 四次挥手

四次挥手可形象理解为以下情景：  

A：B 啊，我不想玩了。  

B：哦，你不想玩了啊，我知道了。  

B：A 啊，好吧，那我也不玩了，拜拜。  

A：好的，拜拜  

四次挥手得考虑相互的状态，A要等B先把手头上的事做完，才能相互断开，也就是多了第三步骤。


### TCP 如何保证高可用

1. **保证有序性**  

为了保证顺序性，每一个包都有一个 ID。在建立连接的时候，会商定起始的 ID 是什么，然后按照 ID 一个个发送。为了保证不丢包，对于发送的包都要进行应答，但是这个应答也不是一个一个来的，而是会应答某个之前的 ID，表示都收到了，这种模式称为`累计确认或者累计应答`。  

为了记录所有发送的包和接收的包，TCP 也需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的 ID 一个个排列，根据处理的情况分成四个部分。
* 发送了并且已经确认的；
* 发送了并且尚未确认的；
* 没有发送，但是已经等待去准备发送的；
* 没有发送，并且暂时还不会发送的。  

为什么要区分第三部分和第四部分呢？没交代的，一下子全交代了不就完了吗？ 
TCP为了做流量控制，接收端会给发送端报一个窗口的大小，叫 `Advertised window`。这个窗口的大小应该等于上面的第二部分加上第三部分，就是已经交代了没做完的加上马上要交代的。超过这个窗口的，接收端做不过来，就不能发送了。使用 Advertised window 来记录接收端处理信息的能力。

2. **解决丢包问题**  

顺序问题和丢包问题都有可能发生，比如，有些包后发的却先到，比如一方已经说 ack 了，另一方没收到（包可能丢了，可能在路上）。   

TCP 解决丢包问题有以下三种方式：
* `超时重试`：也即对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。

* `快速重传`：当接收方收到一个序号大于所期望的报文段时，于是发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。
快速重传为了解决超时重试周期可能相对较长，减少检测时间。

*  `Selective Acknowledgment （SACK）`：在 TCP 头里加一个 SACK,可以将缓存的地图发送给发送方，就可以明确看到哪些数据没有到。

3. **流量控制**   

TCP 双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来，这时候接收方只能把处理不过来的数据存在缓存区里（失序的数据包也会被存放在缓存区里）。  

如果缓存区满了发送方还在疯狂着发送数据，接收方只能把收到的数据包丢掉，大量的丢包会极大着浪费网络资源，因此，我们需要控制发送方的发送速率，也就是流量控制。    

接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发生。



4. **拥塞控制**  

拥塞控制的问题，也是通过窗口的大小来控制的，前面的滑动窗口 rwnd（接收窗口） 是怕发送方把接收方缓存塞满，而拥塞窗口 cwnd（发送窗口），是怕把网络塞满。  

TCP 的拥塞控制主要来避免两种现象，包丢失和超时重传。一旦出现了这些现象就说明，发送速度太快了，要慢一点。
丢包并不代表着通道满了，网上带宽不满也会丢包，这时网络并没有拥塞。TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了，太早和太晚进行拥塞控制都不太合理。  

所以有了 `BBR` 拥塞算法。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。



















